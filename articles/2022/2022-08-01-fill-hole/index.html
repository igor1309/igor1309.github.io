<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift and iOS dev with Igor"/><link rel="canonical" href="https://igor1309.github.com/articles/2022/2022-08-01-fill-hole"/><meta name="twitter:url" content="https://igor1309.github.com/articles/2022/2022-08-01-fill-hole"/><meta name="og:url" content="https://igor1309.github.com/articles/2022/2022-08-01-fill-hole"/><title>Hole Filling | Swift and iOS dev with Igor</title><meta name="twitter:title" content="Hole Filling | Swift and iOS dev with Igor"/><meta name="og:title" content="Hole Filling | Swift and iOS dev with Igor"/><meta name="description" content="Take home Fill Hole assignment."/><meta name="twitter:description" content="Take home Fill Hole assignment."/><meta name="og:description" content="Take home Fill Hole assignment."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon_io/favicon.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift and iOS dev with Igor"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Swift and iOS dev with Igor</a><div class="site-description">The ride of the iOS developer</div><nav><ul><li><a href="/articles" class="selected">Articles</a></li><li><a href="/portfolio">Portfolio</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Hole Filling</h1><p>This was a take home test.</p><blockquote><p>The goal of this task is to build a small image processing library that fills holes in images, along with a small command line utility that uses that library, and answer a¬†few questions.</p></blockquote><p>See detailed assignment in <a href="../../../images/fill-hole/Hole%20Filling%203%20-%20Interview%20Exercise.pdf">Hole Filling 3 - Interview Exercise.pdf</a>.</p><h2>Goals</h2><ol><li>Solve the assignment.</li><li>Demonstrate the ultra-modular design of decoupled composable components.</li></ol><br/><div align="center">
<img src="../../../images/fill-hole/Lenna.png" width="60%" title="Lenna">
<br/>
<p align="center"><cite>Lenna.png</cite></p>
</div><br/><h2>CLI</h2><p>To see in action change your current console directory to <code>fill-hole</code> Swift Package folder and run the following command</p><pre><code>$ swift run fill-hole -h
</code></pre><p>to see <code>fill-hole</code> command line <em>description and arguments</em>:</p><pre><code><span class="type">OVERVIEW</span>: <span class="type">Image Hole Filler</span>.

`fill-hole` is a command line utility that fills the hole <span class="keyword">in</span> the image.
<span class="type">Provide URLs</span> <span class="keyword">for</span> the source image and hole (mask), parameters of the weight function `z` and `e`, and (optional) output
image file name.

<span class="type">USAGE</span>: fill-hole &lt;source&gt; &lt;mask&gt; &lt;z&gt; &lt;e&gt; &lt;connectivity&gt; [&lt;output-file&gt;]

<span class="type">ARGUMENTS</span>:
  &lt;source&gt;                <span class="type">Source</span> image <span class="type">URL</span>.
  &lt;mask&gt;                  <span class="type">Hole</span> (mask) image <span class="type">URL</span>.
  &lt;z&gt;                     `z` parameter of the weight function.
  &lt;e&gt;                     `e` parameter of the weight function: small float value used to avoid division by zero.
  &lt;connectivity&gt;          <span class="type">Pixel</span> connectivity type: <span class="number">4</span> or <span class="number">8</span>.
  &lt;output-file&gt;           (<span class="type">Optional</span>) name of output file without extension. <span class="type">The</span> command only writes to the current
                          directory. (default: output)

<span class="type">OPTIONS</span>:
  -h, --help              <span class="type">Show</span> help information.
</code></pre><p>Output file name could be omitted, its extension, if provided, is ignored (for simplicity of v.001).</p><p>Run the following command:</p><pre><code>$ swift run fill-hole &lt;image url&gt; &lt;hole url&gt; <span class="number">2 0.001 4</span>
</code></pre><p>Drag-n-drop image file instead of <code>&lt;image url&gt;</code>, and mask (hole) file for <code>&lt;hole url&gt;</code>.</p><p>If you miss any argument you'll see an error, for example:</p><pre><code><span class="type">Error</span>: <span class="type">Missing</span> expected argument '&lt;connectivity&gt;'
<span class="type">Help</span>:  &lt;connectivity&gt;  <span class="type">Pixel</span> connectivity type: <span class="number">4</span> or <span class="number">8</span>.
<span class="type">Usage</span>: fill-hole &lt;source&gt; &lt;mask&gt; &lt;z&gt; &lt;e&gt; &lt;connectivity&gt; [&lt;output-file&gt;]
  <span class="type">See</span> 'fill-hole --help' <span class="keyword">for</span> more information.
</code></pre><p>URLs of the source, mask, and output would be printed when the command finishes successfully. Run <code>ls</code> to list folder contents, including the output image:</p><pre><code>$ ls
<span class="type">Package</span>.<span class="property">resolved</span>	<span class="type">README</span>.<span class="property">md</span>		<span class="type">Tests</span>			output.<span class="property">png</span>
<span class="type">Package</span>.<span class="property">swift</span>		<span class="type">Sources</span>			docs
</code></pre><p>Run <code>open output.png</code> to open it.</p><h2>Package Structure</h2><p>The solution is implemented using <em>Swift Package</em>.</p><p>To simplify reasoning, have clear responsibilities, and construct decoupled components, we divided the codebase into the following targets inside one Swift Package:</p><ul><li><code>fill-hole</code> (executable target)</li><li><code>FillHoleCommand</code></li><li><code>FillHoleLib</code></li><li><code>GrayscaleIOLib</code></li></ul><br/><div align="center">
<image src="../../../images/fill-hole/package.png" width="100%" title="Swift Package">
<br/>
<p align="center"><cite>Swift Package</cite></p>
</div><br/><p><code>FillHoleCommand</code>, <code>FillHoleLib</code>, and <code>GrayscaleIOLib</code> are accompanied by tests in their respective test targets.</p><h2>Modules</h2><p>Here is the top-level view of modules and dependencies:</p><br/><div align="center">
<image src="../../../images/fill-hole/modules.png" width="100%" title="Modules">
<br/>
<p align="center"><cite>Modules</cite></p>
</div><br/><p>Here is more detailed view with components:</p><br/><div align="center">
<image src="../../../images/fill-hole/components.png" width="100%" title="Components">
<br/>
<p align="center"><cite>Components</cite></p>
</div><br/><ul><li>Command line utility <code>fill-hole</code> is a simple thin executable wrapper for the <code>FillHoleCommand</code>.</li></ul><ul><li><code>FillHoleCommand</code></li></ul><p><code>FillHoleCommand</code> accepts an <code>input image</code> file, <code>hole</code> (mask) file, weight function parameters <code>ùëß</code> and <code>Œµ</code>, and <code>connectivity</code> type, fills the hole and writes the result to an output image file.</p><p>It's implemented using <a href="https://github.com/apple/swift-argument-parser">Swift Argument Parser</a> by Apple.</p><p><code>FillHoleCommand</code> as a <code>ParsableCommand</code> uses its default implementation of the static func <code>main()</code>. To preserve the functionality and compatibility, there is no way of using constructor injection with <code>FillHoleCommand</code>. As a compromise, we use implicit dependencies (<code>Valuator</code> and <code>Runner</code>) considering <code>FillHoleCommand</code> a <strong>composition layer</strong>, that wraps <code>Valuator</code> and <code>Runner</code> logic.</p><p><code>Valuator</code> and <code>Runner</code> use constructor injection with polymorphic interfaces, so we can easily swap their dependencies.</p><p>The <code>FillHoleCommand</code> doesn‚Äôt support an arbitrary weight function, only the default one with configurable ùëß and Œµ.</p><ul><li><code>FillHoleLib</code></li></ul><p><code>FillHoleLib</code> is a module with algorithm for hole filling. Its two main components are <code>HoleFiller</code> and <code>Balance</code>.</p><p><code>HoleFiller</code> is initialized with <code>PixelConnectivity</code> and <code>Balance</code> and has a function to <code>fill</code> the hole in the image.</p><p><code>Balance</code> holds <code>WeightFunc</code>, either arbitrary or <code>default</code> weighting function<br> <code></code>` 1 / (||u - v||^z + Œµ), <code></code>` where <code>Œµ (epsilon)</code> is a small float value used to avoid division by zero, and <code>||u - v||</code> denotes the euclidean distance between <code>u</code> and <code>v</code>.</p><ul><li><code>GrayscaleIOLib</code></li></ul><p>This is not a generic file IO operations suite, but a very concrete case of loading grayscale images from files and saving such images using <code>ImageIO</code>, the performant API from Apple (<a href="https://developer.apple.com/documentation/imageio/cgimagesource"><code>CGImageSource</code></a>, <a href="https://developer.apple.com/documentation/imageio/cgimagedestination/"><code>CGImageDestination</code></a>).</p><h2>Questions</h2><blockquote><p>1. If there are ùëö boundary pixels and ùëõ pixels inside the hole, what‚Äôs the complexity of the algorithm that fills the hole, assuming that the hole and boundary were already found? Try to also express the complexity only in terms of ùëõ.</p></blockquote><ul><li><code>O(n * m)</code></li><li><code>O(n * ‚àön)</code> - idea: <code>n</code> is like the area of the hole, and <code>m</code> is the perimeter, so O(m) ‚âÉ O(‚àön).</li></ul><blockquote><p>(a) Could you imagine the case where it would be <code>O(n * n)</code>?</p></blockquote><ul><li>Yes, consider long thin rectangle - its perimeter would be <code>~O(n)</code> and overall complexity would be <code>O(n¬≤)</code>.</li></ul><blockquote><p>2. Describe an algorithm that approximates the result in ùëÇ(ùëõ) to a high degree of accuracy. Bonus: implement the suggested algorithm in your library in addition to the algorithm described above.</p></blockquote><p>We could change each hole pixel color to the average color of the boundary. In this case, the complexity would be <code>O(n + m)</code>, where <code>m &lt; n</code>, which is equivalent to <code>O(n)</code>.</p><p>A more granular approach would be the following: divide the boundary into k sets of pixels, calculate average color and "average" coordinates for each set thus creating a set of pixels <code>newBoundary</code>, and run the basic algorithm against the original hole and newBoundary.<br>Complexity:<br>- Creating newBoundary of <code>k</code> pixels from the original boundary of <code>m</code> pixels: <code>m</code> - Filling the hole: <code>k * n</code> - Total <code>O(m) + O(k * n) ‚â≤ O(n)</code></p><blockquote><p>3. Bonus (hard!): Describe and implement an algorithm that finds the exact solution in ùëÇ(ùëõùëôùëúùëîùëõ). In this section, feel free to use any algorithmic functionality provided by external libraries as needed.</p></blockquote><p>In this case I would think about gradually shrinking boundary and hole:</p><pre><code><span class="comment">// pixelConnectivity: PixelConnectivity is given</span>
<span class="keyword">let</span> neighborhood: (<span class="type">Pixel</span>) -&gt; [<span class="type">Pixel</span>] = { pixel <span class="keyword">in</span>
    pixelConnectivity.<span class="call">neighbours</span>(of: pixel)
}

<span class="comment">// copy already found boundary: Boundary = Set&lt;Pixel&gt;</span>
<span class="keyword">var</span> boundary = boundary
<span class="comment">// copy existing hole: Hole = Set&lt;Pixel&gt;</span>
<span class="keyword">var</span> hole = hole

<span class="keyword">while</span> !hole.<span class="call">isEmpty</span> {
    <span class="keyword">let</span> neighbours = boundary.<span class="call">map</span>(neighborhood).<span class="call">reduce</span>([], +))
    <span class="comment">// boundary shrinking inwards</span>
    <span class="keyword">let</span> newBoundary = <span class="type">Set</span>(neighbours).<span class="call">intersection</span>(hole)
    newBoundary.<span class="call">forEach</span> { pixel <span class="keyword">in</span>
        <span class="comment">// paint pixel using neighbours in boundary
        // ...</span>
    }

    hole = hole.<span class="call">subtract</span>(newBoundary)
    boundary = newBoundary
}
</code></pre><h2>A note for the (near) future</h2><p>The upcoming <code>macOS13</code> is able to work with <code>async</code> commands, i.e. <code>FillHoleCommand.main()</code> would be able to run asynchronously.</p><h2>Repo</h2><p>Public repo is <a href="https://github.com/igor1309/fill-hole-public">on the Github</a>.</p></div><div class="item-date"><span>Published on: Aug 1, 2022</span></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/cli">CLI</a></li></ul></article></div><footer><p>Copyright ¬© Igor Malyarov 2021</p><p>Built using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="https://twitter.com/igor1309">Twitter</a> | <a href="/feed.rss">RSS feed</a></p></footer></body></html>