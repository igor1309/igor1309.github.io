<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift and iOS dev with Igor"/><link rel="canonical" href="https://igor1309.github.com/articles/2022/2022-08-25-decorator-protocol-witness"/><meta name="twitter:url" content="https://igor1309.github.com/articles/2022/2022-08-25-decorator-protocol-witness"/><meta name="og:url" content="https://igor1309.github.com/articles/2022/2022-08-25-decorator-protocol-witness"/><title>The Decorator Pattern with Protocol and Protocol Witnesses | Swift and iOS dev with Igor</title><meta name="twitter:title" content="The Decorator Pattern with Protocol and Protocol Witnesses | Swift and iOS dev with Igor"/><meta name="og:title" content="The Decorator Pattern with Protocol and Protocol Witnesses | Swift and iOS dev with Igor"/><meta name="description" content="Exploring the way of the Decorator Pattern implementation with Protocol and Protocol Witnesses"/><meta name="twitter:description" content="Exploring the way of the Decorator Pattern implementation with Protocol and Protocol Witnesses"/><meta name="og:description" content="Exploring the way of the Decorator Pattern implementation with Protocol and Protocol Witnesses"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon_io/favicon.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift and iOS dev with Igor"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Swift and iOS dev with Igor</a><div class="site-description">The ride of the iOS developer</div><nav><ul><li><a href="/articles" class="selected">Articles</a></li><li><a href="/portfolio">Portfolio</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>The Decorator Pattern with Protocol and Protocol Witnesses</h1><p><em>Gang of Four Design Patterns</em>:</p><blockquote><p>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p></blockquote><p><em><a href="https://www.essentialdeveloper.com/articles/design-patterns-in-ios-swift-standing-on-the-shoulder-of-giants-ios-lead-essentials-podcast-014?rq=Decorator">Essential Developer: Design Patterns in iOS/Swift: Standing on the shoulder of giants | iOS Lead Essentials Podcast #014</a></em>:</p><blockquote><p>The Decorator pattern offers a way of adding behavior to an individual object and extending its functionality without subclassing or changing the object’s class.</p></blockquote><blockquote><p>Decorators are useful when you want to add or alter the behavior of individual objects instead of an entire class of objects.</p></blockquote><blockquote><p>To implement the Decorator pattern, you create a new object (decorator) that encloses and conforms to the interface of the component (decoratee) it decorates. The decorator class will contain the extended behavior and forward messages to the decoratee.</p></blockquote><blockquote><p>By doing so, the decorator can be used by the clients of the interface, extending the behavior of the system without needing to alter any existing components.</p></blockquote><blockquote><p>The Decorator pattern is supported by the SOLID principles, especially the Single Responsibility, Liskov Substitution, and Open/Closed Principles.</p></blockquote><blockquote><p>You can use Decorators to add Cross-Cutting concerns such as Logging, Analytics, Threading, Security, etc. into your modules in a clean way while maintaining low coupling in your applications.</p></blockquote><h2>Decorator with protocol</h2><pre><code><span class="keyword">protocol</span> Logger {
    <span class="keyword">func</span> log(<span class="keyword">_</span> message: <span class="type">String</span>)
}

<span class="keyword">final class</span> PrintLogger: <span class="type">Logger</span> {
    <span class="keyword">func</span> log(<span class="keyword">_</span> message: <span class="type">String</span>) {
        <span class="call">print</span>(message)
    }
}

<span class="keyword">protocol</span> SendMessageInput {
    <span class="keyword">associatedtype</span> MessageDetails
    <span class="keyword">associatedtype</span> ChannelID

    <span class="keyword">func</span> send(<span class="keyword">_</span> messageDetails: <span class="type">MessageDetails</span>, to channelID: <span class="type">ChannelID</span>) <span class="keyword">throws</span>
}

<span class="keyword">final class</span> DummySendMessageInput: <span class="type">SendMessageInput</span> {
    <span class="keyword">typealias</span> MessageDetails = <span class="type">String</span>
    <span class="keyword">typealias</span> ChannelID = <span class="type">Int</span>

    <span class="keyword">func</span> send(<span class="keyword">_</span> messageDetails: <span class="type">MessageDetails</span>, to channelID: <span class="type">ChannelID</span>) <span class="keyword">throws</span> {
        <span class="comment">// do nothing</span>
    }
}
</code></pre><h3>Decorator</h3><p>Let’s extend the functionally of the <code>DummySendMessageInput</code> class by logging:</p><p>To create <code>decorator</code> with protocols we need a new class, conforming to <code>SendMessageInput</code>, and initialized with <code>logger</code> and <code>decoratee</code></p><pre><code><span class="keyword">final class</span> DecoratedDummySendMessageInput: <span class="type">SendMessageInput</span> {
    <span class="keyword">private let</span> logger: <span class="type">Logger</span>
    <span class="keyword">private let</span> decoratee: <span class="type">DummySendMessageInput</span>

    <span class="keyword">init</span>(logger: <span class="type">Logger</span>, decoratee: <span class="type">DummySendMessageInput</span>) {
        <span class="keyword">self</span>.<span class="property">logger</span> = logger
        <span class="keyword">self</span>.<span class="property">decoratee</span> = decoratee
    }
}
</code></pre><p>Extended functionality</p><pre><code>     <span class="keyword">func</span> send(<span class="keyword">_</span> messageDetails: <span class="type">String</span>, to channelID: <span class="type">String</span>) <span class="keyword">throws</span> {
        logger.<span class="call">log</span>(“<span class="type">Started</span> sending message.”)
        <span class="keyword">try self</span>.<span class="call">send</span>(messageDetails, to: channelID)
        logger.<span class="call">log</span>(“<span class="type">Started</span> sending message.”)
    }
}
</code></pre><h2>Decorator with Protocol Witness</h2><p>Corresponds to protocol <code>Logger</code></p><pre><code><span class="keyword">struct</span> Logging {
    <span class="keyword">let</span> log: (<span class="type">String</span>) -&gt; <span class="type">Void</span>
}
</code></pre><p>Protocol witness</p><pre><code><span class="keyword">extension</span> <span class="type">Logging</span> {
    <span class="keyword">static let</span> printLogging: <span class="type">Self</span> = .<span class="keyword">init</span> { <span class="call">print</span>($0) }
}
</code></pre><p>Corresponds to protocol <code>SendMessageInput</code></p><pre><code><span class="keyword">struct</span> SendingMessageInput&lt;MessageDetails, ChannelID&gt; {
    <span class="keyword">let</span> send: (<span class="type">MessageDetails</span>, <span class="type">ChannelID</span>) <span class="keyword">throws</span> -&gt; <span class="type">Void</span>
}
</code></pre><p>Protocol witness, corresponds to <code>DummySendMessageInput</code></p><pre><code><span class="keyword">extension</span> <span class="type">SendingMessageInput</span>
<span class="keyword">where</span> <span class="type">MessageDetails</span> == <span class="type">String</span>,
      <span class="type">ChannelID</span> == <span class="type">String</span> {
    <span class="keyword">static var</span> dummy: <span class="type">Self</span> { .<span class="keyword">init</span> { <span class="keyword">_</span>, <span class="keyword">_ in</span> } }
}
</code></pre><h3>Decorator</h3><p>To create <code>decorator</code> with protocol witnesses we do not need a new type, just a function that extends existing type with injected instance of <code>Logging</code></p><pre><code><span class="keyword">extension</span> <span class="type">SendingMessageInput</span> {
    <span class="keyword">func</span> decorated(with logger: <span class="type">Logging</span>) -&gt; <span class="type">Self</span> {
        .<span class="keyword">init</span> { messageDetails, channelID <span class="keyword">in</span>
            logger.<span class="call">log</span>(“<span class="type">Started</span> sending message.”)
            <span class="keyword">try</span> <span class="call">send</span>(messageDetails, channelID)
            logger.<span class="call">log</span>(“<span class="type">Started</span> sending message.”)
        }
    }
}

<span class="keyword">let</span> decoratedStringDummy: <span class="type">SendingMessageInput</span> = .<span class="dotAccess">stringDummy</span>.<span class="call">decorated</span>(with: .<span class="dotAccess">printLogging</span>)
</code></pre><h2>References</h2><ul><li><a href="https://www.essentialdeveloper.com/articles/design-patterns-in-ios-swift-standing-on-the-shoulder-of-giants-ios-lead-essentials-podcast-014?rq=Decorator">Design Patterns in iOS/Swift: Standing on the shoulder of giants | iOS Lead Essentials Podcast #014 - Essential Developer</a></li></ul><ul><li><a href="https://www.essentialdeveloper.com/articles/testing-code-that-uses-dispatchqueue-main-async-ios-lead-essentials-community-qa?rq=Decorator">Testing code that uses DispatchQueue.main.async | iOS Lead Essentials Community Q&amp;A — Essential Developer</a></li></ul><ul><li><strong>Gang of Four (GoF) Design Patterns</strong>: <a href="https://www.goodreads.com/book/show/85009.Design_Patterns">Design Patterns: Elements of Reusable Object-Oriented Software</a> by Erich Gamma, Ralph Johnson, John Vlissides, Richard Helm</li></ul><ul><li><a href="https://springframework.guru/gang-of-four-design-patterns/">Gang of Four Design Patterns - Spring Framework Guru</a></li></ul><ul><li><a href="https://springframework.guru/gang-of-four-design-patterns/decorator-pattern/">Decorator Pattern - Spring Framework Guru</a></li></ul><ul><li><a href="https://www.pointfree.co/episodes/ep34-protocol-witnesses-part-2">Episode #34: Protocol Witnesses: Part 2 (Subscriber-Only)</a></li></ul><ul><li><a href="https://www.pointfree.co/episodes/ep35-advanced-protocol-witnesses-part-1">Episode #35: Advanced Protocol Witnesses: Part 1 (Subscriber-Only)</a></li></ul><ul><li><a href="https://www.pointfree.co/episodes/ep36-advanced-protocol-witnesses-part-2">Episode #36: Advanced Protocol Witnesses: Part 2 (Subscriber-Only)</a></li></ul></div><div class="item-date"><span>Published on: Aug 25, 2022</span></div><span class="tag-list">Tagged with: </span><ul class="tag-list"><li><a href="/tags/decorator-pattern">Decorator Pattern</a></li><li><a href="/tags/protocol-witness">Protocol Witness</a></li></ul></article></div><footer><p>Copyright © Igor Malyarov 2021</p><p>Built using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="https://twitter.com/igor1309">Twitter</a> | <a href="/feed.rss">RSS feed</a></p></footer></body></html>