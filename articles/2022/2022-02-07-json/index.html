<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift and iOSdev with Igor"/><link rel="canonical" href="https://igor1309.github.com/articles/2022/2022-02-07-json"/><meta name="twitter:url" content="https://igor1309.github.com/articles/2022/2022-02-07-json"/><meta name="og:url" content="https://igor1309.github.com/articles/2022/2022-02-07-json"/><title>JSON | Swift and iOSdev with Igor</title><meta name="twitter:title" content="JSON | Swift and iOSdev with Igor"/><meta name="og:title" content="JSON | Swift and iOSdev with Igor"/><meta name="description" content="JSON - essential links and cases"/><meta name="twitter:description" content="JSON - essential links and cases"/><meta name="og:description" content="JSON - essential links and cases"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon_io/favicon.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift and iOSdev with Igor"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Swift and iOSdev with Igor</a><div class="site-description">The ride of the iOS developer</div><nav><ul><li><a href="/articles" class="selected">Articles</a></li><li><a href="/portfolio">Portfolio</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>JSON</h1><ul><li><a href="https://swiftsenpai.com/swift/decode-dynamic-keys-json/">Decode and Flatten JSON with Dynamic Keys Using Decodable</a></li></ul><ul><li><a href="https://www.kiloloco.com/articles/009-using-decodable-dynamic-values-swift/">Using Decodable with Dynamic Values in Swift | Kilo Loco</a></li></ul><ul><li><a href="https://www.donnywals.com/splitting-a-json-object-into-an-enum-and-an-associated-object-with-codable/">Splitting a JSON object into an enum and an associated object with Codable – Donny Wals</a></li></ul><ul><li><a href="https://benscheirman.com/2017/06/swift-json/">Ultimate Guide to JSON Parsing with Swift</a></li></ul><ul><li><a href="https://stackoverflow.com/questions/46292325/what-is-difference-between-optional-and-decodeifpresent-when-using-decodable-for">swift - What is difference between optional and decodeIfPresent when using Decodable for JSON Parsing? - Stack Overflow</a></li></ul><ul><li><a href="https://www.hackingwithswift.com/articles/119/codable-cheat-sheet">Codable cheat sheet – Hacking with Swift</a></li></ul><h2>Solutions</h2><h3>Case 1</h3><p>To decode JSON that represents the array of <em>heterogeneous elements</em> as a <em>struct</em> with fields that hold those elements, use <a href="https://developer.apple.com/documentation/swift/unkeyeddecodingcontainer"><code>UnkeyedDecodingContainer</code></a> and iterate over fields with func <code>decode()</code>. Each call of decode moves iteration to the next element, make sure to decode all fields by checking the <a href="https://developer.apple.com/documentation/swift/unkeyeddecodingcontainer/2892719-count"><code>count</code></a> or <a href="https://developer.apple.com/documentation/swift/unkeyeddecodingcontainer/2892732-isatend"><code>isAtEnd</code></a> properties.</p><pre><code><span class="keyword">import</span> Foundation

<span class="comment">/// `Payload`:
///
///     [
///         0,
///         "XBT/USD"
///     ]
///</span>
<span class="keyword">struct</span> Message {
    <span class="keyword">let</span> channelID: <span class="type">Int</span>
    <span class="keyword">let</span> pair: <span class="type">String</span>
}

<span class="keyword">extension</span> <span class="type">Message</span>: <span class="type">Decodable</span> {
    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">var</span> container = <span class="keyword">try</span> decoder.<span class="call">unkeyedContainer</span>()

        <span class="keyword">let</span> channelID = <span class="keyword">try</span> container.<span class="call">decode</span>(<span class="type">Int</span>.<span class="keyword">self</span>)
        <span class="keyword">let</span> pair = <span class="keyword">try</span> container.<span class="call">decode</span>(<span class="type">String</span>.<span class="keyword">self</span>)

        <span class="keyword">guard</span> container.<span class="property">isAtEnd</span> <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="type">ThereIsMoreToDecodeError</span>()
        }

        <span class="keyword">self</span>.<span class="keyword">init</span>(channelID: channelID, pair: pair)
    }

    <span class="keyword">struct</span> ThereIsMoreToDecodeError: <span class="type">Error</span> {}
}
</code></pre><p>Run to test</p><pre><code><span class="keyword">let</span> payload = <span class="string">"""
    [
        0,
        "XBT/USD"
    ]
"""</span>

<span class="keyword">let</span> data = <span class="type">Data</span>(payload.<span class="property">utf8</span>)
<span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
<span class="keyword">let</span> message = <span class="keyword">try</span> decoder.<span class="call">decode</span>(<span class="type">Message</span>.<span class="keyword">self</span>, from: data)
</code></pre><h3>Case 2</h3><p>To decode heterogeneous array where elements have common and different parts use struct with enum field for changing part and non-enum for common part.</p><pre><code><span class="keyword">import</span> Foundation

<span class="comment">/// `Payload`
///
///     [
///         {
///             "channelID": 10001,
///             "channelName": "ticker",
///             "event": "subscriptionStatus"
///         },
///         {
///             "errorMessage": "Subscription depth not supported",
///             "channelName": "ticker",
///             "event": "subscriptionStatus"
///         }
///     ]</span>
<span class="keyword">struct</span> Message {
    <span class="keyword">typealias</span> Name = <span class="type">String</span>
    <span class="keyword">typealias</span> Event = <span class="type">String</span>

    <span class="keyword">let</span> oneOf: <span class="type">OneOf</span>
    <span class="keyword">let</span> name: <span class="type">Name</span>
    <span class="keyword">let</span> event: <span class="type">Event</span>
}

<span class="keyword">extension</span> <span class="type">Message</span>: <span class="type">Decodable</span> {
    <span class="keyword">enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> name, event
    }

    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">let</span> container = <span class="keyword">try</span> decoder.<span class="call">singleValueContainer</span>()
        <span class="keyword">let</span> oneOf = <span class="keyword">try</span> container.<span class="call">decode</span>(<span class="type">OneOf</span>.<span class="keyword">self</span>)

        <span class="keyword">let</span> keyedContainer = <span class="keyword">try</span> decoder.<span class="call">container</span>(keyedBy: <span class="type">CodingKeys</span>.<span class="keyword">self</span>)
        <span class="keyword">let</span> name = <span class="keyword">try</span> keyedContainer.<span class="call">decode</span>(<span class="type">Name</span>.<span class="keyword">self</span>, forKey: .<span class="dotAccess">name</span>)
        <span class="keyword">let</span> event = <span class="keyword">try</span> keyedContainer.<span class="call">decode</span>(<span class="type">Name</span>.<span class="keyword">self</span>, forKey: .<span class="dotAccess">event</span>)

        <span class="keyword">self</span>.<span class="keyword">init</span>(oneOf: oneOf, name: name, event: event)
    }
}

<span class="keyword">enum</span> OneOf: <span class="type">Decodable</span> {
    <span class="keyword">case</span> errorMessage(<span class="type">ErrorMessage</span>)
    <span class="keyword">case</span> channelID(<span class="type">ChannelID</span>)

    <span class="keyword">struct</span> ErrorMessage: <span class="type">Decodable</span> {
        <span class="keyword">let</span> errorMessage: <span class="type">String</span>
    }

    <span class="keyword">struct</span> ChannelID: <span class="type">Decodable</span> {
        <span class="keyword">let</span> channelID: <span class="type">Int</span>
    }

    <span class="keyword">enum</span> CodingKeys: <span class="type">String</span>, <span class="type">CodingKey</span> {
        <span class="keyword">case</span> errorMessage, channelID
    }

    <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span> {
        <span class="keyword">do</span> {
            <span class="keyword">let</span> errorMessage = <span class="keyword">try</span> <span class="type">ErrorMessage</span>(from: decoder)
            <span class="keyword">self</span> = .<span class="call">errorMessage</span>(errorMessage)
        } <span class="keyword">catch</span> {
            <span class="keyword">let</span> channelID = <span class="keyword">try</span> <span class="type">ChannelID</span>(from: decoder)
            <span class="keyword">self</span> = .<span class="call">channelID</span>(channelID)
        }
    }
}
</code></pre><p>Run to test</p><pre><code><span class="keyword">let</span> payload = <span class="string">"""
     [
         {
             "channelID": 10001,
             "name": "ticker",
             "event": "subscriptionStatus"
         },
         {
             "errorMessage": "Subscription depth not supported",
             "name": "ticker",
             "event": "subscriptionStatus"
         }
     ]
"""</span>

<span class="keyword">let</span> data = <span class="type">Data</span>(payload.<span class="property">utf8</span>)
<span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()
<span class="keyword">let</span> messages = <span class="keyword">try</span> decoder.<span class="call">decode</span>([<span class="type">Message</span>].<span class="keyword">self</span>, from: data)
</code></pre></div><div class="item-date"><span>Published on: Feb 7, 2022</span></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/json">JSON</a></li></ul></article></div><footer><p>Copyright © Igor Malyarov 2021</p><p>Built using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="https://twitter.com/igor1309">Twitter</a> | <a href="/feed.rss">RSS feed</a></p></footer></body></html>