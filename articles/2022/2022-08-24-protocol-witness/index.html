<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swift and iOS dev with Igor"/><link rel="canonical" href="https://igor1309.github.com/articles/2022/2022-08-24-protocol-witness"/><meta name="twitter:url" content="https://igor1309.github.com/articles/2022/2022-08-24-protocol-witness"/><meta name="og:url" content="https://igor1309.github.com/articles/2022/2022-08-24-protocol-witness"/><title>Protocol Witnesses | Swift and iOS dev with Igor</title><meta name="twitter:title" content="Protocol Witnesses | Swift and iOS dev with Igor"/><meta name="og:title" content="Protocol Witnesses | Swift and iOS dev with Igor"/><meta name="description" content="Re-watch and recap of Point-Free series on Protocol Witnesses"/><meta name="twitter:description" content="Re-watch and recap of Point-Free series on Protocol Witnesses"/><meta name="og:description" content="Re-watch and recap of Point-Free series on Protocol Witnesses"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon_io/favicon.ico" type="image/x-icon"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swift and iOS dev with Igor"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Swift and iOS dev with Igor</a><div class="site-description">The ride of the iOS developer</div><nav><ul><li><a href="/articles" class="selected">Articles</a></li><li><a href="/portfolio">Portfolio</a></li><li><a href="/about">About</a></li></ul></nav></div></header><div class="wrapper"><article><div class="content"><h1>Protocol Witnesses</h1><h2><a href="https://www.pointfree.co/episodes/ep33-protocol-witnesses-part-1">Episode #33: Protocol Witnesses: Part 1</a></h2><p>Episode #33 • Oct 15, 2018 • Subscriber-Only</p><p>Protocols are a great tool for abstraction, but aren’t the only one. This week we begin to explore the tradeoffs of using protocols by highlighting a few areas in which they fall short in order to demonstrate how we can recover from these problems using a different tool and different tradeoffs.</p><blockquote><p>... protocols are quite rigid in that a type can conform to a given protocol in only one single way. Sometimes it’s completely valid and even technically correct to allow a type to conform to a protocol in multiple ways.</p></blockquote><h2><a href="https://www.pointfree.co/episodes/ep34-protocol-witnesses-part-2">Episode #34: Protocol Witnesses: Part 2</a></h2><p>Episode #34 • Oct 22, 2018 • Subscriber-Only</p><p>Last time we covered some basics with protocols, and demonstrated one of their biggest pitfalls: types can only conform to a protocol a single time. Sometimes it’s valid and correct for a type to conform to a protocol in many ways. We show how to remedy this by demonstrating that one can scrap any protocol in favor of a simple datatype, and in doing so opens up a whole world of composability.</p><blockquote><p>What’s the point of going through the motions of translating protocols to structs when Swift has given us protocols ...?</p></blockquote><blockquote><p>First, this process of translating protocols into structs and then passing around explicit witnesses is literally what the Swift compiler is doing under the hood. It’s nice to know that there isn’t any real magic happening behind the scenes, and that the concepts are super simple.</p></blockquote><blockquote><p>Second, explicit witnesses give us a whole new level composability with our conformances that was impossible to see when we are dealing with protocols.</p></blockquote><p>Using <code>contramap</code>.</p><h2><a href="https://www.pointfree.co/episodes/ep35-advanced-protocol-witnesses-part-1">Episode #35: Advanced Protocol Witnesses: Part 1</a></h2><p>Episode #35 • Oct 29, 2018 • Subscriber-Only</p><p>Now that we know it’s possible to replace protocols with concrete datatypes, and now that we’ve seen how that opens up new ways to compose things that were previously hidden from us, let’s go a little deeper. We will show how to improve the ergonomics of writing Swift in this way, and show what Swift’s powerful conditional conformance feature is represented by just plain functions.</p><p>Rename <code>contramap</code> to <code>pullback</code>.</p><h2><a href="https://www.pointfree.co/episodes/ep36-advanced-protocol-witnesses-part-2">Episode #36: Advanced Protocol Witnesses: Part 2</a></h2><p>Episode #36 • Nov 5, 2018 • Subscriber-Only</p><p>We complete our dictionary for translating Swift protocol concepts into concrete datatypes and functions. This includes protocol inheritance, protocol extensions, default implementations and protocols with associated types. Along the way we will also show how concrete types can express things that are currently impossible with Swift protocols.</p><blockquote><p>translating protocols to concrete datatypes has revealed just how simple some of these seemingly complex features are. We could clear away the fog and see that a protocol feature is really just functions and composition and generics in disguise! Even the dreaded “Self or associated type” error becomes much less dreadful when you realize that it’s just a couple hidden generics.</p></blockquote><h2><a href="https://www.pointfree.co/episodes/ep37-protocol-oriented-library-design-part-1">Episode #37: Protocol-Oriented Library Design: Part 1</a></h2><p>Episode #37 • Nov 12, 2018 • Subscriber-Only</p><p>Perhaps the most popular approach to code reuse and extensibility in Swift is to liberally adopt protocol-oriented programming, and many Swift libraries are designed with protocol-heavy APIs. In today’s episode we refactor a sample library to use protocols and examine the pros and cons of this approach.</p><h2><a href="https://www.pointfree.co/episodes/ep38-protocol-oriented-library-design-part-2">Episode #38: Protocol-Oriented Library Design: Part 2</a></h2><p>Episode #38 • Nov 19, 2018 • Subscriber-Only</p><p>With our library fully generalized using protocols, we show off the flexibility of our abstraction by adding new conformances and functionality. In fleshing out our library we find out why protocols may not be the right tool for the job.</p><p>Snapshotting views as strings.</p><h2><a href="https://www.pointfree.co/episodes/ep39-witness-oriented-library-design">Episode #39: Witness-Oriented Library Design</a></h2><p>Episode #39 • Nov 26, 2018 • Subscriber-Only</p><p>We previously refactored a library using protocols to make it more flexible and extensible but found that it wasn’t quite as flexible or extensible as we wanted it to be. This week we re-refactor our protocols away to concrete datatypes using our learnings from earlier in the series.</p><h2><a href="https://www.pointfree.co/episodes/ep40-async-functional-refactoring">Episode #40: Async Functional Refactoring</a></h2><p>Episode #40 • Dec 17, 2018 • Subscriber-Only</p><p>The snapshot testing library we have been designing over the past few weeks has a serious problem: it can’t snapshot asynchronous values, like web views and anything that uses delegates or callbacks. Today we embark on a no-regret refactor to fix this problem with the help of a well-studied and well-understood functional type that we have discussed numerous times before.</p><p>Sync snapshotting web views fails, need async.</p><p>Async snapshotting. <code>Parallel</code> type.</p><p>Async pullback.</p><h2><a href="https://www.pointfree.co/episodes/ep41-a-tour-of-snapshot-testing">Episode #41: A Tour of Snapshot Testing</a></h2><p>Episode #41 • Dec 18, 2018 • Free Episode</p><p>Our snapshot testing library is now officially open source! In order to show just how easy it is to integrate the library into any existing code base, we add some snapshot tests to a popular open source library for attributed strings. This gives us the chance to see how easy it is to write all new, domain-specific snapshot strategies from scratch.</p><h2><a href="https://www.pointfree.co/episodes/ep86-swiftui-snapshot-testing">Episode #86: SwiftUI Snapshot Testing</a></h2><p>Episode #86 • Dec 23, 2019 • Free Episode</p><p>In this week’s free holiday episode we show what it looks like to snapshot test a SwiftUI application in our architecture and compare this style of integration testing against XCTest’s UI testing tools.</p><p>Snapshotting alerts (UIWindow, hosting application @11:44)</p><p><code>windowedImage</code> snapshotting strategy</p><p>Turning animation off and on. Not working for alerts.</p><p>...play a simple user script by sending actions to the store and then take screenshots of what the application looks like at each step of the way</p></div><div class="item-date"><span>Published on: Aug 24, 2022</span></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/pointfree">Point-Free</a></li><li><a href="/tags/protocol-witness">Protocol Witness</a></li></ul></article></div><footer><p>Copyright © Igor Malyarov 2021</p><p>Built using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="https://twitter.com/igor1309">Twitter</a> | <a href="/feed.rss">RSS feed</a></p></footer></body></html>